###Lab5 Report  
#【练习0】填写已有实验  
本实验依赖实验1/2/3/4。请把你做的实验1/2/3/4的代码填入本实验中代码中有"LAB1"/"LAB2"/"LAB3"/"LAB4"的注释相应部分。注意:为了能够正确执行lab5的测试应用程序,可能需对已完成的实验1/2/3/4的代码进行进一步改进。  

> 本次实验练习0不紧紧要求像前面实验的练习0一样将前期实验的内容添加到本次实验中，而且需要根据注释内容对前面实验做相应的改进；以便于本次实验的进行；首先按照前面实验一样，将1/2/3/4次实验的内容完全拷贝到相应的位置，然后我们查看注释，在相应的位置做调整；第一处需要改进的地方就是lab1练习2处，我们需要添加一个系统调用的门，即将原来设置的门更该为系统调用的门即可，如下:
```  
 for(i=0; i<len; i++)
 	SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
 //SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_KERNEL);
 SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);
 lidt(&idt_pd);//载入IDT;
 return;
```  
第二处需要改进的地方是lab1练习3处，我门根据注释，每tick_num个时钟周期将current->need_resched置为1；第三处需要改进的地方是lab4练习1处，根据注释我们需要增加对新进程几个参数的初始化，将proc的wait_state初始化为0,proc的cptr,yptr,optr都初始化为NULL；第四处需要改进的地方就是lab4练习2处,我们需要增加一个函数调用，即set_links。这样整个练习0就完成了。  

#【练习1】加载应用程序并执行  
do_execv函数调用load_icode(位于kern/process/proc.c中)来加载并解析一个处于内存中的ELF执行文件格式的应用程序,建立相应的用户内存空间来放置应用程序的代码段、数据段等,且要设置好proc_struct结构中的成员变量trapframe中的内容,确保在执行此进程后,能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。  

> 本练习只要按照注释，将trapfram中的内容设置好即可，即将tf_cs置为USER_CS，tf_ds、tf_es、tf_ss置为USER_DS，esp置为栈地址，eip置为二进制程序代码入口，eflags置为FL_IF即可。当加载了一个新的应用程序之后，首先为其分配一块存储空间，然后设置相应页表映射，建立堆栈，然后设置上下文信息的存储，当cpu选择当前进程运行是开始运行。  

#【练习2】父进程复制自己的内存空间给子进程  
创建子进程的函数do_fork在执行中将拷贝当前进程(即父进程)的用户内存地址空间中的合法内容到新进程中(子进程),完成内存资源的复制。具体是通过copy_range函数(位于kern/mm/pmm.c中)实现的,请补充copy_range的实现,确保能够正确执行。  

> 根据注释进行相应的code即可；copy-on-write机制的实现简要描述：首先需要设置一个参数来分辨对一个存储单元的操作是读还是写，如果是读则按照正常情况让进程访问地址即可；若是写，则需要进行操作，第一步，在本进程所占有的存储空间内分配处一块和需要访问的存储空间一样大小的空间，先利用读操作将需要访问的地址内容拷贝到当前进程中来，然后当前进程就有了一个私有的资源，然后再对其做相应的写操作即可。  

#【练习3】阅读分析源代码,理解进程执行fork/exec/wait/exit的实现,以及系统调用的实现  
请在实验报告中简要说明你对	fork/exec/wait/exit函数的分析。并回答如下问题:  
#【练习3问题1】  
请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的?  

> fork:fork函数实现的是进程的创建过程，父进程进行拷贝生成了一个相应的子进程；  
exec:exe函数实现的是函数运行进程，它是通过调用load_icode可以把进程设置为运行  
wait:wait函数可以把相应进程设置为等待状态  
exit:进程结束  

#【练习3问题2】  
请给出ucore中一个用户态进程的执行状态生命周期图(包执行状态,执行状态之间的变换关系,以及产生变换的事件或函数调用)。(字符方式画即可)  

> 创建---(进入就绪队列)--->就绪---(被调度)--->运行---(运行完毕或被杀死)--->退出;创建---(进入就绪队列)--->就绪---(被调度)--->运行---(等待某种资源)--->等待---(已经获得资源)--->就绪;创建---(进入就绪队列)--->就绪---(被调度)--->运行---(cpu被抢占)--->就绪。  
